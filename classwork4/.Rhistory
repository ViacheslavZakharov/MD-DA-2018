source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
gmp <- read.table(file="gmp.dat")
gmp <- read.table(file="gmp.dat")
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
gmp <- read.table(file="gmp.dat")
estimate.scaling.exponent <- function(a, y0=6611, response=gmp$pcgmp,
predictor = gmp$pop, maximum.iterations=100, deriv.step = 1/100,
step.scale = 1e-12, stopping.deriv = 1/100) {
mse <- function(a) { mean((response - y0*predictor^a)^2) }
for (iteration in 1:maximum.iterations) {
deriv <- (mse(a+deriv.step) - mse(a))/deriv.step
a <- a - step.scale*deriv
if (abs(deriv) <= stopping.deriv) { break() }
}
fit <- list(a=a,iterations=iteration,
converged=(iteration < maximum.iterations))
return(fit)
}
#Пример вызова с начальным занчением a
estimate.scaling.exponent(0.15)
gmp <- read.table(file="gmp.dat")
gmp$pop <- gmp$gmp / gmp$pcgmp
estimate.scaling.exponent <- function(a, y0=6611, response=gmp$pcgmp,
predictor = gmp$pop, maximum.iterations=100, deriv.step = 1/100,
step.scale = 1e-12, stopping.deriv = 1/100) {
# проверка корректности входных данных
stopifnot(is.numeric(a),length(a)==1)
stopifnot(is.numeric(y0),length(y0)==1)
stopifnot(is.numeric(deriv.step))
mse <- function(a) { mean((response - y0*predictor^a)^2) }
for (iteration in 1:maximum.iterations) {
deriv <- (mse(a+deriv.step) - mse(a))/deriv.step
a <- a - step.scale*deriv
if (abs(deriv) <= stopping.deriv) { break() }
}
fit <- list(a=a,iterations=iteration,
converged=(iteration < maximum.iterations))
return(fit)
}
#Пример вызова с начальным занчением a
estimate.scaling.exponent(0.15)
#С помошью полученного коэффициента постройте кривую (функция curve) зависимости
#Удалите точку из набора исходных данных случайным образом, как изменилось статистическая оценка коэффициента a?
#Запустите оценку несколько раз с разных стартовых точек. Как изменилось значение a?
gmp <- read.table(file="gmp.dat")
gmp$pop <- gmp$gmp / gmp$pcgmp
estimate.scaling.exponent <- function(a, y0=6611, response=gmp$pcgmp,
predictor = gmp$pop, maximum.iterations=100,
deriv.step = 1/100, step.scale = 1e-12,
stopping.deriv = 1/100) {
mse <- function(a) { mean((response - y0*predictor^a)^2) }
for (iteration in 1:maximum.iterations) {
deriv <- (mse(a+deriv.step) - mse(a))/deriv.step
a <- a - step.scale*deriv
if (abs(deriv) <= stopping.deriv) { break() }
}
fit <- list(a=a,iterations=iteration,
converged=(iteration < maximum.iterations))
return(fit)
}
gmp <- read.table(file="gmp.dat")
gmp$pop <- gmp$gmp / gmp$pcgmp
estimate.scaling.exponent <- function(a, y0=6611, response=gmp$pcgmp,
predictor = gmp$pop, maximum.iterations=100,
deriv.step = 1/100, step.scale = 1e-12,
stopping.deriv = 1/100) {
mse <- function(a) { mean((response - y0*predictor^a)^2) }
for (iteration in 1:maximum.iterations) {
deriv <- (mse(a+deriv.step) - mse(a))/deriv.step
a <- a - step.scale*deriv
if (abs(deriv) <= stopping.deriv) { break() }
}
fit <- list(a=a,iterations=iteration,
converged=(iteration < maximum.iterations))
return(fit)
}
#Пример вызова с начальным занчением a
estimate.scaling.exponent(0.15)
#С помошью полученного коэффициента постройте кривую (функция curve) зависимости
#Удалите точку из набора исходных данных случайным образом, как изменилось статистическая оценка коэффициента a?
#Запустите оценку несколько раз с разных стартовых точек. Как изменилось значение a?
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
y0 <- 6611 # параметр распределения
plot (gmp$pop, gmp$pcgmp, xlab = "Население", ylab = "Доход на душу населения")
curve(y0*(x)^(res.1$a), add=TRUE, col="red") # построение модели с подобранным коэффициентом
y0 <- 6611 # параметр распределения
plot (gmp$pop, gmp$pcgmp, xlab = "Население", ylab = "Доход на душу населения", log="xy")
curve(y0*(x)^(res.1$a), add=TRUE, col="red") # построение модели с подобранным коэффициентом
gmp <- read.table(file="gmp.dat")
gmp$pop <- gmp$gmp / gmp$pcgmp
estimate.scaling.exponent <- function(a, y0=6611, response=gmp$pcgmp,
predictor = gmp$pop, maximum.iterations=100, deriv.step = 1/100,
step.scale = 1e-12, stopping.deriv = 1/100) {
# проверка корректности входных данных
stopifnot(is.numeric(a),length(a)==1)
stopifnot(is.numeric(y0),length(y0)==1)
stopifnot(is.numeric(deriv.step))
mse <- function(a) { mean((response - y0*predictor^a)^2) }
for (iteration in 1:maximum.iterations) {
deriv <- (mse(a+deriv.step) - mse(a))/deriv.step
a <- a - step.scale*deriv
if (abs(deriv) <= stopping.deriv) { break() }
}
fit <- list(a=a,iterations=iteration,
converged=(iteration < maximum.iterations))
return(fit)
}
res.1 <- estimate.scaling.exponent(0.15)
res.1
y0 <- 6611 # параметр распределения
plot (gmp$pop, gmp$pcgmp, xlab = "Население", ylab = "Доход на душу населения", log="xy")
curve(y0*(x)^(res.1$a), add=TRUE, col="red") # построение модели с подобранным коэффициентом
random.number <- round(runif(1, min=1, max=nrow(gmp))) # число из нормального распределения на интервале от 1 до кол-ва строк датафрейма gmp
random.number
nrow(gmp) # количество строк (точек) до удаления
gmp <- gmp [-random.number,]
nrow(gmp) # количество строк после удаления
res.2 <- estimate.scaling.exponent(0.15)
res.2$a # полученный коэффициент
res.2$a-res.1$a # разница значений полученных коэффициентов
estimate.scaling.exponent(0)$a
estimate.scaling.exponent(0.1)$a
estimate.scaling.exponent(0.15)$a
estimate.scaling.exponent(0.18)$a
estimate.scaling.exponent(0.2)$a
estimate.scaling.exponent(0.4)$a
estimate.scaling.exponent(0.8)$a
estimate.scaling.exponent(1)$a
estimate.scaling.exponent(1.5)$a
gmp <- read.table(file="gmp.dat")
gmp$pop <- gmp$gmp / gmp$pcgmp
estimate.scaling.exponent <- function(a, y0=6611, response=gmp$pcgmp,
predictor = gmp$pop, maximum.iterations=100, deriv.step = 1/100,
step.scale = 1e-12, stopping.deriv = 1/100) {
# проверка корректности входных данных
stopifnot(is.numeric(a),length(a)==1)
stopifnot(is.numeric(y0),length(y0)==1)
stopifnot(is.numeric(deriv.step))
mse <- function(a) { mean((response - y0*predictor^a)^2) }
for (iteration in 1:maximum.iterations) {
deriv <- (mse(a+deriv.step) - mse(a))/deriv.step
a <- a - step.scale*deriv
if (abs(deriv) <= stopping.deriv) { break() }
}
fit <- list(a=a,iterations=iteration,
converged=(iteration < maximum.iterations))
return(fit)
}
res.1 <- estimate.scaling.exponent(0.15)
res.1
y0 <- 6611 # параметр распределения
plot (gmp$pop, gmp$pcgmp, xlab = "Население", ylab = "Доход на душу населения")
curve(y0*(x)^(res.1$a), add=TRUE, col="red") # построение модели с подобранным коэффициентом
random.number <- round(runif(1, min=1, max=nrow(gmp))) # число из нормального распределения на интервале от 1 до кол-ва строк датафрейма gmp
random.number
nrow(gmp) # количество строк (точек) до удаления
gmp <- gmp [-random.number,]
nrow(gmp) # количество строк после удаления
res.2 <- estimate.scaling.exponent(0.15)
res.2$a # полученный коэффициент
res.2$a-res.1$a # разница значений полученных коэффициентов
estimate.scaling.exponent(0)$a
estimate.scaling.exponent(0.1)$a
estimate.scaling.exponent(0.15)$a
estimate.scaling.exponent(0.18)$a
estimate.scaling.exponent(0.2)$a
estimate.scaling.exponent(0.4)$a
estimate.scaling.exponent(0.8)$a
estimate.scaling.exponent(1)$a
estimate.scaling.exponent(1.5)$a
gmp <- read.table(file="gmp.dat")
gmp$pop <- gmp$gmp / gmp$pcgmp
estimate.scaling.exponent <- function(a, y0=6611, response=gmp$pcgmp,
predictor = gmp$pop, maximum.iterations=100, deriv.step = 1/100,
step.scale = 1e-12, stopping.deriv = 1/100) {
# проверка корректности входных данных
stopifnot(is.numeric(a),length(a)==1)
stopifnot(is.numeric(y0),length(y0)==1)
stopifnot(is.numeric(deriv.step))
mse <- function(a) { mean((response - y0*predictor^a)^2) }
for (iteration in 1:maximum.iterations) {
deriv <- (mse(a+deriv.step) - mse(a))/deriv.step
a <- a - step.scale*deriv
if (abs(deriv) <= stopping.deriv) { break() }
}
fit <- list(a=a,iterations=iteration,
converged=(iteration < maximum.iterations))
return(fit)
}
res.1 <- estimate.scaling.exponent(0.15)
res.1
y0 <- 6611 # параметр распределения
plot (gmp$pop, gmp$pcgmp, xlab = "Население", ylab = "Доход на душу населения", log="xy")
curve(y0*(x)^(res.1$a), add=TRUE, col="red") # построение модели с подобранным коэффициентом
random.number <- round(runif(1, min=1, max=nrow(gmp))) # число из нормального распределения на интервале от 1 до кол-ва строк датафрейма gmp
random.number
nrow(gmp) # количество строк (точек) до удаления
gmp <- gmp [-random.number,]
nrow(gmp) # количество строк после удаления
res.2 <- estimate.scaling.exponent(0.15)
res.2$a # полученный коэффициент
res.2$a-res.1$a # разница значений полученных коэффициентов
estimate.scaling.exponent(0)$a
estimate.scaling.exponent(0.1)$a
estimate.scaling.exponent(0.15)$a
estimate.scaling.exponent(0.18)$a
estimate.scaling.exponent(0.2)$a
estimate.scaling.exponent(0.4)$a
estimate.scaling.exponent(0.8)$a
estimate.scaling.exponent(1)$a
estimate.scaling.exponent(1.5)$a
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
max=nrow(gmp)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
nrow(gmp)
length(gmp)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
пьз
gmp
result.0.15$a
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork4/gmp.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
gmp <- read.table(file="gmp.dat")
gmp$pop <- gmp$gmp / gmp$pcgmp
estimate.scaling.exponent <- function(a, y0=6611, response=gmp$pcgmp,
predictor = gmp$pop, maximum.iterations=100, deriv.step = 1/100,
step.scale = 1e-12, stopping.deriv = 1/100) {
mse <- function(a) { mean((response - y0*predictor^a)^2) }
for (iteration in 1:maximum.iterations) {
deriv <- (mse(a+deriv.step) - mse(a))/deriv.step
a <- a - step.scale*deriv
if (abs(deriv) <= stopping.deriv) { break() }
}
fit <- list(a=a,iterations=iteration,
converged=(iteration < maximum.iterations))
return(fit)
}
factorial <- function(n) {
stopifnot(n>=0) # проверка корректности n>=0
if (n==1 || n==0) return(1)
return(n*factorial(n-1))
}
# проверка функции факториала
numbers <- c(0:10)
res.1 <- vector(mode = "integer", length = length(numbers)) # в вектор будем записывать рез-ты
for (i in 1:length(numbers)){
res.1[i]=factorial(numbers[i])
}
df.1 <- data.frame(Number=numbers, Factorial=res.1)
df.1
fibonacci <- function(n){
stopifnot(n>=0) # проверка корректности n>=0
if (n==0) return(0)
if (n==1 || n==2) return(1)
return(fibonacci(n-1)+fibonacci(n-2))
}
# проверка функции Фибоначчи
indexes <- c(0:10)
res.2 <- vector(mode = "integer", length = length(indexes)) # вектор чисел Фибоначчи
for (i in 1:length(indexes)){
res.2[i]=fibonacci(indexes[i])
}
df.2 <- data.frame(Index=indexes, Number=res.2)
df.2
estimate.scaling.exponent(0.15)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
rec.factorial(5)
?stopifnot
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
rec.factorial(-1)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
rec.fibonachi(5)
rec.fibonachi(10)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
rec.fibonachi(10)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
debugSource('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
rec.fibonachi(5)
debugSource('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
debugSource('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
debugSource('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
source('~/1учеба/4курс/многомерныеДанные/MD-DA-2018/classwork5/classwork5.R', encoding = 'UTF-8', echo=TRUE)
rec.fibonachi(-5)
q
